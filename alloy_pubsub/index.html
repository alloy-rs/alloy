<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="alloy-pubsub"><title>alloy_pubsub - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="alloy_pubsub" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (d7f6ebace 2024-06-16)" data-channel="nightly" data-search-js="search-0fe7219eb170c82e.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/alloy-rs/core/main/assets/favicon.ico"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../alloy_pubsub/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../alloy_pubsub/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt="logo"></a><h2><a href="../alloy_pubsub/index.html">alloy_pubsub</a><span class="version">0.1.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">alloy_pubsub</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/alloy_pubsub/lib.rs.html#1-28">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="alloy-pubsub"><a class="doc-anchor" href="#alloy-pubsub">Â§</a>alloy-pubsub</h2>
<p>Ethereum JSON-RPC <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">publish-subscribe</a> tower service and type definitions.</p>
<h3 id="overview"><a class="doc-anchor" href="#overview">Â§</a>Overview</h3>
<p>PubSub services, unlike regular RPC services, are long-lived and
bidirectional. They are used to subscribe to events on the server, and
receive notifications when those events occur.</p>
<p>The PubSub system here consists of 3 logical parts:</p>
<ul>
<li>The <strong>frontend</strong> is the part of the system that the user interacts with.
It exposes a simple API that allows the user to issue requests and manage
subscriptions.</li>
<li>The <strong>service</strong> is an intermediate layer that manages request/response
mappings, subscription aliasing, and backend lifecycle events. Running
<a href="connect/trait.PubSubConnect.html#method.into_service" title="method alloy_pubsub::connect::PubSubConnect::into_service"><code>PubSubConnect::into_service</code></a> will spawn a long-lived service task. The
service exists to manage the lifecycle of requests and subscriptions over
reconnections, and to serve any number of <strong>frontends</strong>.</li>
<li>The <strong>backend</strong> is an actively running connection to the server. Users
should NEVER instantiate a backend directly. Instead, they should use
<a href="connect/trait.PubSubConnect.html#method.into_service" title="method alloy_pubsub::connect::PubSubConnect::into_service"><code>PubSubConnect::into_service</code></a> for some connection object. Backends
are responsible for managing the connection to the server,accepting user
requests from the <strong>service</strong> and forwarding server responses to the
<strong>service</strong>.</li>
</ul>
<p>This crate provides the following:</p>
<ul>
<li><a href="connect/trait.PubSubConnect.html" title="trait alloy_pubsub::connect::PubSubConnect"><code>PubSubConnect</code></a>: A trait for instantiating a PubSub service by connecting
to some <strong>backend</strong>. Implementors of this trait are responsible for
the precise connection details, and for spawning the <strong>backend</strong> task.
Users should ALWAYS call <a href="connect/trait.PubSubConnect.html#method.into_service" title="method alloy_pubsub::connect::PubSubConnect::into_service"><code>PubSubConnect::into_service</code></a> to get a running
service with a running backend.</li>
<li><a href="handle/struct.ConnectionHandle.html" title="struct alloy_pubsub::handle::ConnectionHandle"><code>ConnectionHandle</code></a>: A handle to a running <strong>backend</strong>. This type is
returned by <a href="connect/trait.PubSubConnect.html#tymethod.connect" title="method alloy_pubsub::connect::PubSubConnect::connect">PubSubConnect::connect</a>, and owned by the <strong>service</strong>.
Dropping the handle will shut down the <strong>backend</strong>.</li>
<li><a href="handle/struct.ConnectionInterface.html" title="struct alloy_pubsub::handle::ConnectionInterface"><code>ConnectionInterface</code></a>: The reciprocal of <a href="handle/struct.ConnectionHandle.html" title="struct alloy_pubsub::handle::ConnectionHandle">ConnectionHandle</a>. This type
is owned by the <strong>backend</strong>, and is used to communicate with the
<strong>service</strong>. Dropping the interface will notify the <strong>service</strong> of a
terminal error.</li>
<li><a href="frontend/struct.PubSubFrontend.html" title="struct alloy_pubsub::frontend::PubSubFrontend"><code>PubSubFrontend</code></a>: The <strong>frontend</strong>. A handle to a running PubSub
<strong>service</strong>. It is used to issue requests and subscription lifecycle
instructions to the <strong>service</strong>.</li>
<li><a href="sub/struct.RawSubscription.html" title="struct alloy_pubsub::sub::RawSubscription"><code>RawSubscription</code></a>: A handle to a subscription. This type is yielded by
the <strong>service</strong> when a user issues a <code>get_subscription()</code> request. It is a
<code>tokio::broadcast</code> channel which receives notifications from the <strong>service</strong>
when the server sends a notification for the subscription.</li>
<li><a href="sub/struct.Subscription.html" title="struct alloy_pubsub::sub::Subscription"><code>Subscription</code></a>: A handle to a subscription expecting a specific response
type. A wrapper around <a href="sub/struct.RawSubscription.html" title="struct alloy_pubsub::sub::RawSubscription"><code>RawSubscription</code></a> that deserializes notifications
into the expected type, and allows the user to accept or discard unexpected
responses.</li>
<li><a href="sub/enum.SubscriptionItem.html" title="enum alloy_pubsub::sub::SubscriptionItem"><code>SubscriptionItem</code></a>: An item in a typed <a href="sub/struct.Subscription.html" title="struct alloy_pubsub::sub::Subscription"><code>Subscription</code></a>. This type is
yielded by the subscription via the <code>recv_any()</code> API a notification is
received and contains the deserialized item. If deserialization fails, it
contains the raw JSON value.</li>
</ul>
<h3 id="on-handling-subscriptions"><a class="doc-anchor" href="#on-handling-subscriptions">Â§</a>On Handling Subscriptions</h3>
<p>For a normal request, the user sends a request to the <strong>frontend</strong>, and
later receives a response via a tokio oneshot channel. This is straightforward
and easy to reason about. Subscriptions, however, are side-effects of other
requests, and are long-lived. They are managed by the <strong>service</strong> and
identified by a <code>U256</code> id. The <strong>service</strong> uses this id to manage the
subscription lifecycle, and to dispatch notifications to the correct
subscribers.</p>
<h4 id="server--local-ids"><a class="doc-anchor" href="#server--local-ids">Â§</a>Server &amp; Local IDs</h4>
<p>When a user issues a subscription request, the <strong>frontend</strong> sends a
subscription request to the <strong>service</strong>. The <strong>service</strong> dispatches it to the
RPC server via the <strong>backend</strong>. The <strong>service</strong> then intercepts the RPC server
response containing the serve id, and assigns a <code>local_id</code> to the subscription.
This <code>local_id</code> is used to identify the subscription in the <strong>service</strong> and in
tasks consuming the subscription, while the <code>server_id</code> is used to identify the
subscription to the RPC server, and to associate notifications with specific
active subscriptions.</p>
<p>This allows us to use long-lived <code>local_id</code> values to manage subscriptions over
multiple reconnections, without having to notify frontend users of the ID change
when the server connection is lost. It also prevents race conditions when
unsubscribing during or immediately after a reconnection.</p>
<h4 id="what-is-a-subscription-request"><a class="doc-anchor" href="#what-is-a-subscription-request">Â§</a>What is a subscription request?</h4>
<p>The <strong>service</strong> uses the <code>is_subscription()</code> method in the request to determine
whether a given RPC request is a subscription. In general, subscription requests
use the <code>eth_subscribe</code> method. However, other methods may also be used to
create subscriptions, such as <code>admin_peerEvents</code>. To allow custom subscriptions
on unknown methods, the <code>Request</code>, <code>SerializedRequest</code> and <code>RpcCall</code> expose
<code>set_is_subscription()</code>, which can be used to mark any given request as a
subscription.</p>
<p>When marking a request as a subscription, the <strong>service</strong> will intercept the
RPC response, which MUST be a <code>U256</code> value. Subscription requests that return
anything other than a <code>U256</code> value will not function.</p>
<h4 id="subscription-lifecycle"><a class="doc-anchor" href="#subscription-lifecycle">Â§</a>Subscription Lifecycle</h4>
<p>Regular Request Lifecycle</p>
<ol>
<li>The user issues a request to the <strong>frontend</strong>.</li>
<li>The <strong>frontend</strong> sends the request to the <strong>service</strong>, with a oneshot channel
to receive the response.</li>
<li>The <strong>service</strong> stores the oneshot channel in its <code>RequestManager</code>.</li>
<li>The <strong>service</strong> sends the request to the <strong>backend</strong>.</li>
<li>The <strong>backend</strong> sends the request to the RPC server.</li>
<li>The RPC server responds with a JSON RPC response.</li>
<li>The <strong>backend</strong> sends the response to the <strong>service</strong>.</li>
<li>The <strong>service</strong> sends the response to the waiting task via the oneshot.</li>
</ol>
<p>Subscription Request Lifecycle:</p>
<ol>
<li>The user issues a subscription request to the <strong>frontend</strong>.</li>
<li>The <strong>frontend</strong> sends the request to the <strong>service</strong>, with a oneshot channel
to receive the response.</li>
<li>The <strong>service</strong> stores the oneshot channel in its <code>RequestManager</code>.</li>
<li>The <strong>service</strong> sends the request to the <strong>backend</strong>.</li>
<li>The <strong>backend</strong> sends the request to the RPC server.</li>
<li>The RPC server responds with a <code>U256</code> value (the <code>server_id</code>).</li>
<li>The <strong>backend</strong> sends the response to the <strong>service</strong>.</li>
<li>The <strong>service</strong> assigns a <code>local_id</code> to the subscription, creates a
subscription broadcast channel, and stores the relevant information in its
<code>SubscriptionManager</code>.</li>
<li>The <strong>service</strong> overwrites the JSON RPC response with the <code>local_id</code>.</li>
<li>The <strong>service</strong> sends the response to the waiting task via the oneshot.</li>
</ol>
<p>Subscription Notification Lifecycle</p>
<ol>
<li>The RPC server sends a notification to the <strong>backend</strong>.</li>
<li>The <strong>backend</strong> sends the notification to the <strong>service</strong>.</li>
<li>The <strong>service</strong> looks up the <code>local_id</code> i1n its <code>SubscriptionManager</code>.</li>
<li>If present, the <strong>service</strong> sends the notification to the relevant channel.
<ol>
<li>Otherwise, the <strong>service</strong> ignores the notification.</li>
</ol>
</li>
</ol>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="connect/index.html" title="mod alloy_pubsub::connect">connect</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="frontend/index.html" title="mod alloy_pubsub::frontend">frontend</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="handle/index.html" title="mod alloy_pubsub::handle">handle</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="ix/index.html" title="mod alloy_pubsub::ix">ix</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="managers/index.html" title="mod alloy_pubsub::managers">managers</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="service/index.html" title="mod alloy_pubsub::service">service</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="sub/index.html" title="mod alloy_pubsub::sub">sub</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ConnectionHandle.html" title="struct alloy_pubsub::ConnectionHandle">ConnectionHandle</a></div><div class="desc docblock-short">A handle to a backend. Communicates to a <code>ConnectionInterface</code> on the
backend.</div></li><li><div class="item-name"><a class="struct" href="struct.ConnectionInterface.html" title="struct alloy_pubsub::ConnectionInterface">ConnectionInterface</a></div><div class="desc docblock-short">The reciprocal of <a href="handle/struct.ConnectionHandle.html" title="struct alloy_pubsub::handle::ConnectionHandle"><code>ConnectionHandle</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.PubSubFrontend.html" title="struct alloy_pubsub::PubSubFrontend">PubSubFrontend</a></div><div class="desc docblock-short">A <code>PubSubFrontend</code> is <a href="alloy_transport::Transport"><code>Transport</code></a> composed of a channel to a running
PubSub service.</div></li><li><div class="item-name"><a class="struct" href="struct.RawSubscription.html" title="struct alloy_pubsub::RawSubscription">RawSubscription</a></div><div class="desc docblock-short">A Subscription is a feed of notifications from the server, identified by a
local ID.</div></li><li><div class="item-name"><a class="struct" href="struct.Subscription.html" title="struct alloy_pubsub::Subscription">Subscription</a></div><div class="desc docblock-short">A Subscription is a feed of notifications from the server of a specific
type <code>T</code>, identified by a local ID.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.SubscriptionItem.html" title="enum alloy_pubsub::SubscriptionItem">SubscriptionItem</a></div><div class="desc docblock-short">An item in a typed <a href="sub/struct.Subscription.html" title="struct alloy_pubsub::sub::Subscription"><code>Subscription</code></a>. This is either the expected type, or
some serialized value of another type.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.PubSubConnect.html" title="trait alloy_pubsub::PubSubConnect">PubSubConnect</a></div><div class="desc docblock-short">Configuration objects that contain connection details for a backend.</div></li></ul></section></div></main></body></html>