// @generated by scripts/provider_methods.rs. Do not modify by hand.
#[macro_export]
#[doc(hidden)]
macro_rules! _pd_all_methods {
    ([$($extra:tt)*] $m:path) => {
        $m!([$($extra)*]

[] fn root[](& self) -> & RootProvider < N > [];
[] fn client[](& self) -> ClientRef < '_ > [];
[] fn weak_client[](& self) -> WeakClient [];
[] fn get_accounts[](& self) -> ProviderCall < NoParams , Vec < Address > > [];
[] fn get_blob_base_fee[](& self) -> ProviderCall < NoParams , U128 , u128 > [];
[] fn get_block_number[](& self) -> ProviderCall < NoParams , U64 , BlockNumber > [];
[] fn call[](& self , tx : N :: TransactionRequest) -> EthCall < N , Bytes > [];
[] fn call_many[<'req>](& self , bundles : & 'req Vec < Bundle > ,) -> EthCallMany < 'req , N , Vec < Vec < EthCallResponse > > > [];
[] fn simulate[<'req>](& self , payload : & 'req SimulatePayload ,) -> RpcWithBlock < & 'req SimulatePayload , Vec < SimulatedBlock < N :: BlockResponse > > > [];
[] fn get_chain_id[](& self) -> ProviderCall < NoParams , U64 , u64 > [];
[] fn create_access_list[<'a>](& self , request : & 'a N :: TransactionRequest ,) -> RpcWithBlock < & 'a N :: TransactionRequest , AccessListResult > [];
[] fn estimate_gas[](& self , tx : N :: TransactionRequest) -> EthCall < N , U64 , u64 > [];
[async] fn estimate_eip1559_fees_with[](& self , estimator : Eip1559Estimator ,) -> TransportResult < Eip1559Estimation > [];
[async] fn estimate_eip1559_fees[](& self) -> TransportResult < Eip1559Estimation > [];
[async] fn get_fee_history[](& self , block_count : u64 , last_block : BlockNumberOrTag , reward_percentiles : & [f64] ,) -> TransportResult < FeeHistory > [];
[] fn get_gas_price[](& self) -> ProviderCall < NoParams , U128 , u128 > [];
[] fn get_account[](& self , address : Address) -> RpcWithBlock < Address , alloy_consensus :: Account > [];
[] fn get_balance[](& self , address : Address) -> RpcWithBlock < Address , U256 , U256 > [];
[] fn get_block[](& self , block : BlockId) -> EthGetBlock < N :: BlockResponse > [];
[] fn get_block_by_hash[](& self , hash : BlockHash) -> EthGetBlock < N :: BlockResponse > [];
[] fn get_block_by_number[](& self , number : BlockNumberOrTag) -> EthGetBlock < N :: BlockResponse > [];
[async] fn get_block_transaction_count_by_hash[](& self , hash : BlockHash ,) -> TransportResult < Option < u64 > > [];
[async] fn get_block_transaction_count_by_number[](& self , block_number : BlockNumberOrTag ,) -> TransportResult < Option < u64 > > [];
[] fn get_block_receipts[](& self , block : BlockId ,) -> ProviderCall < (BlockId ,) , Option < Vec < N :: ReceiptResponse > > > [];
[] fn get_code_at[](& self , address : Address) -> RpcWithBlock < Address , Bytes > [];
[async] fn watch_blocks[](& self) -> TransportResult < FilterPollerBuilder < B256 > > [];
[async] fn watch_pending_transactions[](& self) -> TransportResult < FilterPollerBuilder < B256 > > [];
[async] fn watch_logs[](& self , filter : & Filter) -> TransportResult < FilterPollerBuilder < Log > > [];
[async] fn watch_full_pending_transactions[](& self ,) -> TransportResult < FilterPollerBuilder < N :: TransactionResponse > > [];
[async] fn get_filter_changes[<R : RpcRecv>](& self , id : U256) -> TransportResult < Vec < R > > [where Self : Sized ,];
[async] fn get_filter_changes_dyn[](& self , id : U256) -> TransportResult < FilterChanges > [];
[async] fn get_filter_logs[](& self , id : U256) -> TransportResult < Vec < Log > > [];
[async] fn uninstall_filter[](& self , id : U256) -> TransportResult < bool > [];
[async] fn watch_pending_transaction[](& self , config : PendingTransactionConfig ,) -> Result < PendingTransaction , PendingTransactionError > [];
[async] fn get_logs[](& self , filter : & Filter) -> TransportResult < Vec < Log > > [];
[] fn get_proof[](& self , address : Address , keys : Vec < StorageKey > ,) -> RpcWithBlock < (Address , Vec < StorageKey >) , EIP1186AccountProofResponse > [];
[] fn get_storage_at[](& self , address : Address , key : U256 ,) -> RpcWithBlock < (Address , U256) , StorageValue > [];
[] fn get_transaction_by_hash[](& self , hash : TxHash ,) -> ProviderCall < (TxHash ,) , Option < N :: TransactionResponse > > [];
[] fn get_transaction_by_block_hash_and_index[](& self , block_hash : B256 , index : usize ,) -> ProviderCall < (B256 , Index) , Option < N :: TransactionResponse > > [];
[] fn get_raw_transaction_by_block_hash_and_index[](& self , block_hash : B256 , index : usize ,) -> ProviderCall < (B256 , Index) , Option < Bytes > > [];
[] fn get_transaction_by_block_number_and_index[](& self , block_number : BlockNumberOrTag , index : usize ,) -> ProviderCall < (BlockNumberOrTag , Index) , Option < N :: TransactionResponse > > [];
[] fn get_raw_transaction_by_block_number_and_index[](& self , block_number : BlockNumberOrTag , index : usize ,) -> ProviderCall < (BlockNumberOrTag , Index) , Option < Bytes > > [];
[] fn get_raw_transaction_by_hash[](& self , hash : TxHash) -> ProviderCall < (TxHash ,) , Option < Bytes > > [];
[] fn get_transaction_count[](& self , address : Address ,) -> RpcWithBlock < Address , U64 , u64 , fn (U64) -> u64 > [];
[] fn get_transaction_receipt[](& self , hash : TxHash ,) -> ProviderCall < (TxHash ,) , Option < N :: ReceiptResponse > > [];
[async] fn get_uncle[](& self , tag : BlockId , idx : u64) -> TransportResult < Option < N :: BlockResponse > > [];
[async] fn get_uncle_count[](& self , tag : BlockId) -> TransportResult < u64 > [];
[] fn get_max_priority_fee_per_gas[](& self) -> ProviderCall < NoParams , U128 , u128 > [];
[async] fn new_block_filter[](& self) -> TransportResult < U256 > [];
[async] fn new_filter[](& self , filter : & Filter) -> TransportResult < U256 > [];
[async] fn new_pending_transactions_filter[](& self , full : bool) -> TransportResult < U256 > [];
[async] fn send_raw_transaction[](& self , encoded_tx : & [u8] ,) -> TransportResult < PendingTransactionBuilder < N > > [];
[async] fn send_raw_transaction_conditional[](& self , encoded_tx : & [u8] , conditional : TransactionConditional ,) -> TransportResult < PendingTransactionBuilder < N > > [];
[async] fn send_transaction[](& self , tx : N :: TransactionRequest ,) -> TransportResult < PendingTransactionBuilder < N > > [];
[async] fn send_tx_envelope[](& self , tx : N :: TxEnvelope ,) -> TransportResult < PendingTransactionBuilder < N > > [];
[async] fn send_transaction_internal[](& self , tx : SendableTx < N > ,) -> TransportResult < PendingTransactionBuilder < N > > [];
[async] fn subscribe_blocks[](& self ,) -> TransportResult < alloy_pubsub :: Subscription < N :: HeaderResponse > > [];
[async] fn subscribe_pending_transactions[](& self ,) -> TransportResult < alloy_pubsub :: Subscription < B256 > > [];
[async] fn subscribe_full_pending_transactions[](& self ,) -> TransportResult < alloy_pubsub :: Subscription < N :: TransactionResponse > > [];
[async] fn subscribe_logs[](& self , filter : & Filter ,) -> TransportResult < alloy_pubsub :: Subscription < Log > > [];
[async] fn subscribe[<Pa , R>](& self , params : Pa) -> TransportResult < alloy_pubsub :: Subscription < R > > [where Pa : RpcSend , R : RpcRecv , Self : Sized ,];
[async] fn unsubscribe[](& self , id : B256) -> TransportResult < () > [];
[] fn syncing[](& self) -> ProviderCall < NoParams , SyncStatus > [];
[] fn get_client_version[](& self) -> ProviderCall < NoParams , String > [];
[] fn get_sha3[](& self , data : & [u8]) -> ProviderCall < (String ,) , B256 > [];
[] fn get_net_version[](& self) -> ProviderCall < NoParams , U64 , u64 > [];
[async] fn raw_request[<Pa , R>](& self , method : Cow < 'static , str > , params : Pa) -> TransportResult < R > [where Pa : RpcSend , R : RpcRecv , Self : Sized ,];
[async] fn raw_request_dyn[](& self , method : Cow < 'static , str > , params : & RawValue ,) -> TransportResult < Box < RawValue > > [];
[] fn transaction_request[](& self) -> N :: TransactionRequest [];


        );
    };
}
